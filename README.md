# SpruceID Take Home Assignment

Instructions:

The goal of this assignment is to implement a web service that proves ownership of a private key. It should be done in Rust.

Details:

- Two actors are involved: a holder, and a verifier web service.

- The holder should be a script that signs a payload with the private key and calls the verifier API.

- The verifier should provide an API that verifies the payload and signature to establish that the holder controls the private key.

- A nonce should be used to prevent replay of attestations.

Advice:

- If you are unable to implement a complete solution, write down your thoughts and explain the limitations of your solution.

- This assignment is fairly simple, and its purpose is mostly to show familiarity with Rust, backend development, and a basic understanding of public key cryptography.

## Setup

1. Clone the repository
2. Have Rust installed (My cargo version is 1.85.0)
3. Run `make build` to build both the holder and the verifier.
3. Run `make run-verifier` to start the verifier in a terminal.
4. In a new terminal, run `make run-holder` to start the holder.

After running the holder, you should see the output of 4 cases being tested:

1. A payload with a valid signature and nonce, it should be verified successfully.
2. A payload with a valid signature and nonce followed by another payload using the same nonce, it should fail.
3. A payload with a valid nonce but an invalid signature, it should fail.
4. A payload with a valid signature and nonce, but waits for the nonce to expire before sending it to the verifier, it should fail.

## Implementation details

Both the holder and the verifier were implemented in the same project,
just for the sake of simplicity. In a real-world scenario, we would be
talking about different projects/contexts and etc.

The verifier is a Rocket web service, and the holder is a Rust script.

Also, both were implemented in single files, again, to keep things simple.

### Verifier

The verifier is a simple Rocket web service that provides three endpoints:

- `GET /nonce`: Generates a nonce and returns it.
  - The nonce is generated and stored in memory, and it is valid for 5 seconds.
  - The generated nonce is returned to the holder.
- `POST /verify`: Verifies the payload and signature and returns a success message if it is valid.
  - The payload is parsed and we check if:
    - The nonce is valid (it was generated by the verifier and it is not expired).
    - The signature is valid.
  - Returns 200 if is everything is ok, 401 if it's not the case.

The nonce is a UUID string, and it was implemented in the server side because:

- I thought it would be easier to have a centralized control of the generation process, making sure
that every nonce is unique. Even though it increases the server load and latency.

### Holder

The holder is a simple Rust script that generates a key pair, ask the verifier for a nonce,
signs a simple text message (for simplicity), and sends the payload to the verifier.

The payload includes:

- The nonce
- The message
- The signature
- The public key

Its strange to send the public key in the payload, in a real world I would assume
that the verifier would already have the public key, but for the sake of this
assignment, I decided to send it to make it easier.

Also, generating a new key pair every time is not ideal, I'm doing like that
to keep everything in memory, again for simplicity.

